// Code Generated by Sidekick is for learning and experimentation purposes only.
import mongoose from "mongoose";
import dotenv from "dotenv";
dotenv.config();
import Candidate from "./models/candidate.js";
import Remark from "./models/remarks.js";


const isNonEmptyString = (v) => typeof v === "string" && v.trim().length > 0;

async function run() {
   const MONGO_URL = process.env.MONGO_URL;
   if (!MONGO_URL) throw new Error("Missing MONGO_URL");
   const ADMIN_EMPLOYEE_ID = "66d2c41d78d17906be04f1ac";
   if (!ADMIN_EMPLOYEE_ID)
      throw new Error("Missing ADMIN_EMPLOYEE_ID (Employee _id)");

   await mongoose.connect(MONGO_URL);
   const adminId = new mongoose.Types.ObjectId(ADMIN_EMPLOYEE_ID);

   const cursor = Candidate.find({
      remarks: { $type: "string", $ne: "" },
   })
      .select({ _id: 1, remarks: 1, createdOn: 1, lastUpdatedOn: 1 })
      .lean()
      .cursor();

   const batch = [];
   const BATCH_SIZE = 1000;

   for await (const c of cursor) {
      if (!isNonEmptyString(c.remarks)) continue;

      const when = c.lastUpdatedOn || c.createdOn || new Date();

      batch.push({
         candidateId: c._id,
         employeeId: adminId,
         remarks: c.remarks.trim(),
         createdAt: when,
         updatedAt: when,
      });

      if (batch.length >= BATCH_SIZE) {
         await Remark.insertMany(batch, { ordered: false });
         batch.length = 0;
      }
   }

   if (batch.length) await Remark.insertMany(batch, { ordered: false });

   // OPTIONAL (after verifying):
   // await Candidate.updateMany(
   //   { remarks: { $type: "string", $ne: "" } },
   //   { $unset: { remarks: "" } }
   // );

   await mongoose.disconnect();
}

run().catch(async (e) => {
   console.error(e);
   try {
      await mongoose.disconnect();
   } finally {
      process.exit(1);
   }
});
